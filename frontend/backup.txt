import { useState, useEffect, useRef, useMemo } from 'react';
import { usePrivy } from '@privy-io/react-auth';
import { createWalletClient, createPublicClient, custom, http, parseGwei } from 'viem';
import { ethers } from 'ethers';
import './App.css';

const contractAddress = import.meta.env.VITE_CONTRACT_ADDRESS;

const MONAD_TESTNET = {
  id: 10143,
  name: 'Monad Testnet',
  nativeCurrency: { name: 'Monad', symbol: 'MON', decimals: 18 },
  rpcUrls: { default: { http: ['https://testnet-rpc.monad.xyz'] } },
};

const abi = [
  "function startGame(uint256 seed) external payable returns (bytes32)",
  "function submitMovesAndCashOut(bytes32 gameId, uint8[] calldata clickedTiles) external",
  "event GameStarted(bytes32 gameId, address player, uint256 bet)",
  "event CashedOut(bytes32 gameId, uint256 reward)",
  "event GameOver(bytes32 gameId)",
  "function getGameInfo(bytes32 gameId) view returns (address player, uint256 seed, uint256 bet, bool active, uint8[] clickedTiles)"
];

function useTransaction() {
  const { user, ready } = usePrivy();
  const walletClient = useRef(null);
  const publicClient = useRef(null);
  const [isWalletReady, setIsWalletReady] = useState(false);

  // Auto switch to Monad Testnet
  const switchToMonadTestnet = async (provider) => {
    try {
      // Try to switch to Monad Testnet
      await provider.request({
        method: 'wallet_switchEthereumChain',
        params: [{ chainId: `0x${MONAD_TESTNET.id.toString(16)}` }],
      });
    } catch (switchError) {
      // This error code indicates that the chain has not been added to MetaMask/Rabby
      if (switchError.code === 4902) {
        try {
          await provider.request({
            method: 'wallet_addEthereumChain',
            params: [
              {
                chainId: `0x${MONAD_TESTNET.id.toString(16)}`,
                chainName: MONAD_TESTNET.name,
                nativeCurrency: MONAD_TESTNET.nativeCurrency,
                rpcUrls: MONAD_TESTNET.rpcUrls.default.http,
                blockExplorerUrls: ['https://testnet-explorer.monad.xyz'],
              },
            ],
          });
        } catch (addError) {
          console.error('Failed to add Monad Testnet:', addError);
          throw addError;
        }
      } else {
        console.error('Failed to switch to Monad Testnet:', switchError);
        throw switchError;
      }
    }
  };

  useEffect(() => {
    async function initWalletClient() {
      if (!ready || !user?.wallet?.address) {
        walletClient.current = null;
        publicClient.current = null;
        setIsWalletReady(false);
        return;
      }

      try {
        publicClient.current = createPublicClient({
          chain: MONAD_TESTNET,
          transport: http()
        });

        let provider = null;
        if (user.wallet?.getEthereumProvider) {
          provider = await user.wallet.getEthereumProvider();
        } else if (user.wallet?.getEthersProvider) {
          const ethersProvider = await user.wallet.getEthersProvider();
          provider = ethersProvider?.provider;
        } else if (user.wallet?.provider) {
          provider = user.wallet.provider;
        } else if (
          user.wallet?.walletClientType === 'metamask' ||
          user.wallet?.connectorType === 'injected'
        ) {
          provider = window.ethereum;
        }

        if (!provider) {
          throw new Error("No compatible provider found!");
        }

        // Auto switch to Monad Testnet
        await switchToMonadTestnet(provider);

        walletClient.current = createWalletClient({
          chain: MONAD_TESTNET,
          transport: custom(provider),
          account: user.wallet.address
        });

        setIsWalletReady(true);
      } catch (error) {
        console.error("Failed to initialize wallet client:", error);
        walletClient.current = null;
        publicClient.current = null;
        setIsWalletReady(false);
      }
    }

    initWalletClient();
  }, [user, ready]);

  async function sendTransactionAndConfirm({ to, data, gas, value = 0 }) {
    try {
      if (!walletClient.current || !publicClient.current) {
        throw new Error("Wallet client not initialized.");
      }

      if (!user?.wallet?.address) {
        throw new Error("User wallet address not available.");
      }

      const txHash = await walletClient.current.sendTransaction({
        to,
        account: user.wallet.address,
        data,
        gas: BigInt(gas),
        value: BigInt(value),
        maxFeePerGas: parseGwei('50'),
        maxPriorityFeePerGas: parseGwei('2'),
      });

      return txHash;
    } catch (error) {
      console.error("Error in sendTransactionAndConfirm:", error);
      throw error;
    }
  }

  return { walletClient, publicClient, sendTransactionAndConfirm, isWalletReady };
}

function App() {
  const { user, authenticated, login, logout } = usePrivy();
  const { walletClient, publicClient, sendTransactionAndConfirm, isWalletReady } = useTransaction();

  const [gameId, setGameId] = useState(null);
  const [gameActive, setGameActive] = useState(false);
  const [tiles, setTiles] = useState(Array(36).fill(0)); // 0: unrevealed, 1: safe, 2: bomb
  const [revealedTiles, setRevealedTiles] = useState(Array(36).fill(false));
  const [clickedTileSequence, setClickedTileSequence] = useState([]);
  const [seed, setSeed] = useState(null);
  const [tilesClicked, setTilesClicked] = useState(0);
  const [totalEarned, setTotalEarned] = useState(0);
  const [totalLost, setTotalLost] = useState(0);
  const [selectedBet, setSelectedBet] = useState("0.01");
  const [status, setStatus] = useState("Status: Not connected");
  const [gameError, setGameError] = useState(false);
  const [gameErrorText, setGameErrorText] = useState("");
  const [isTransactionPending, setIsTransactionPending] = useState(false);
  const [gameEndedWithBomb, setGameEndedWithBomb] = useState(false);

  const contractInterface = useMemo(() => new ethers.Interface(abi), []);

  useEffect(() => {
    if (!authenticated) {
      setStatus("Status: Not connected");
    } else if (!isWalletReady) {
      setStatus("Status: Connecting wallet...");
    } else {
      setStatus("üéÆ Ready to play!");
    }
  }, [authenticated, isWalletReady]);

  // SECURITY: Only check individual tiles when clicked, don't pre-generate all bomb positions
  const checkIfTileIsBomb = (position) => {
    if (!seed) return false;
    
    const bombPositions = new Set();
    let currentSeed = BigInt(seed);
    let attempts = 0;
    
    // Generate bomb positions one by one until we have 9 or find our position
    while (bombPositions.size < 9 && attempts < 100) {
      const encoded = ethers.AbiCoder.defaultAbiCoder().encode(
        ["uint256", "uint256"], 
        [currentSeed, bombPositions.size]
      );
      const hash = ethers.keccak256(encoded);
      const pos = Number(BigInt(hash) % BigInt(36));
      
      // If this is the position we're checking and it's a bomb
      if (pos === position && !bombPositions.has(pos)) {
        return true;
      }
      
      bombPositions.add(pos);
      
      currentSeed = BigInt(ethers.keccak256(
        ethers.AbiCoder.defaultAbiCoder().encode(["uint256"], [currentSeed])
      ));
      
      attempts++;
    }
    
    return false;
  };

  // Only reveal all bombs when game ends with a bomb
  const revealAllBombs = () => {
    if (!seed) return;
    
    const bombPositions = new Set();
    let currentSeed = BigInt(seed);
    let attempts = 0;
    
    while (bombPositions.size < 9 && attempts < 100) {
      const encoded = ethers.AbiCoder.defaultAbiCoder().encode(
        ["uint256", "uint256"], 
        [currentSeed, bombPositions.size]
      );
      const hash = ethers.keccak256(encoded);
      const pos = Number(BigInt(hash) % BigInt(36));
      
      bombPositions.add(pos);
      
      currentSeed = BigInt(ethers.keccak256(
        ethers.AbiCoder.defaultAbiCoder().encode(["uint256"], [currentSeed])
      ));
      
      attempts++;
    }
    
    // Update tiles to show all bombs
    const updatedTiles = [...tiles];
    const updatedRevealed = [...revealedTiles];
    
    bombPositions.forEach(pos => {
      updatedTiles[pos] = 2; // Mark as bomb
      updatedRevealed[pos] = true; // Reveal it
    });
    
    setTiles(updatedTiles);
    setRevealedTiles(updatedRevealed);
  };

  // SECURITY FIX: Initialize board without revealing bomb positions
  const initializeBoard = () => {
    // Don't reveal bomb positions - just create empty board
    return Array(36).fill(0); // All tiles start as unrevealed
  };

  const handleStartGame = async () => {
    try {
      setGameError(false);
      setGameErrorText("");
      setIsTransactionPending(true);

      if (!authenticated || !user?.wallet?.address) {
        setStatus("‚ùå Please connect your wallet first.");
        return;
      }

      if (!isWalletReady || !walletClient.current || !publicClient.current) {
        setStatus("‚ùå Wallet not ready. Please wait or refresh.");
        return;
      }

      setStatus("üé≤ Starting game...");

      const newSeed = Math.floor(Math.random() * 1e9);
      setSeed(newSeed);

      const betValue = ethers.parseEther(selectedBet);
      const data = contractInterface.encodeFunctionData("startGame", [newSeed]);

      const txHash = await sendTransactionAndConfirm({
        to: contractAddress,
        data,
        gas: 300000,
        value: betValue,
      });

      setStatus(`üîÑ Transaction sent! Hash: ${txHash.slice(0, 10)}...`);

      const receipt = await publicClient.current.waitForTransactionReceipt({ hash: txHash });

      const parsedLogs = receipt.logs
        .map(log => {
          try {
            return contractInterface.parseLog(log);
          } catch (e) {
            return null;
          }
        })
        .filter(log => log !== null);

      const gameStartedEvent = parsedLogs.find(e => e.name === "GameStarted");
      if (!gameStartedEvent) {
        throw new Error("GameStarted event not found.");
      }

      const receivedGameId = gameStartedEvent.args.gameId;
      setGameId(receivedGameId);
      setGameActive(true);
      setTilesClicked(0);
      setClickedTileSequence([]);
      
      // SECURITY FIX: Don't reveal bomb positions in frontend
      setTiles(initializeBoard()); // Empty board without bomb positions
      setRevealedTiles(Array(36).fill(false));
      setGameEndedWithBomb(false);
      setTotalLost(prev => prev + parseFloat(selectedBet));

      setStatus(`üéÆ Game Started! ID: ${receivedGameId.slice(0, 10)}...`);
    } catch (err) {
      console.error("Error starting game:", err);
      setGameError(true);
      setGameErrorText(err.message);
      setStatus(`‚ùå Failed to start: ${err.message}`);
    } finally {
      setIsTransactionPending(false);
    }
  };

  const handleTileClick = (pos) => {
    if (!gameActive || revealedTiles[pos] || isTransactionPending) return;

    // Check if this tile is a bomb using the same logic as the contract
    const isBomb = checkIfTileIsBomb(pos);
    
    const updatedRevealed = [...revealedTiles];
    updatedRevealed[pos] = true;
    setRevealedTiles(updatedRevealed);

    const updatedTiles = [...tiles];
    
    if (isBomb) {
      // Player hit a bomb - game over
      updatedTiles[pos] = 2; // Mark as bomb
      setTiles(updatedTiles);
      
      // Reveal all bombs for visual feedback
      revealAllBombs();
      
      setGameActive(false);
      setGameEndedWithBomb(true);
      setStatus("üí• Bomb! Game Over");
      return;
    }

    // Safe tile
    updatedTiles[pos] = 1; // Mark as safe
    setTiles(updatedTiles);
    
    setTilesClicked(prev => prev + 1);
    setClickedTileSequence(prev => [...prev, pos]);

    const multiplier = calculateMultiplier(tilesClicked + 1) * 0.95;
    setStatus(`‚úÖ Safe! Tiles: ${tilesClicked + 1} | Multiplier: ${multiplier.toFixed(4)}x`);
  };

  const handleCashOut = async () => {
    if (!gameActive || tilesClicked === 0 || isTransactionPending) {
      setStatus("‚ùå Cannot cash out now");
      return;
    }

    if (!isWalletReady || !walletClient.current || !publicClient.current) {
      setStatus("‚ùå Wallet not ready.");
      return;
    }

    try {
      setIsTransactionPending(true);
      setStatus("üí∞ Cashing out...");

      // SECURITY FIX: Only log non-sensitive debug info
      console.log("--- Cashout Debug ---");
      console.log("Game ID:", gameId);
      console.log("Clicked tile sequence:", clickedTileSequence);
      console.log("Number of safe moves:", clickedTileSequence.length);
      console.log("Player address:", user?.wallet?.address);
      console.log("--- End Debug ---");

      const data = contractInterface.encodeFunctionData("submitMovesAndCashOut", [gameId, clickedTileSequence]);
      
      const txHash = await sendTransactionAndConfirm({
        to: contractAddress,
        data,
        gas: 300000 + clickedTileSequence.length * 20000,
      });

      setStatus(`üîÑ Processing cashout... Hash: ${txHash.slice(0, 10)}...`);

      const receipt = await publicClient.current.waitForTransactionReceipt({ hash: txHash });
      
      console.log("Transaction status:", receipt.status === 1n ? "Success" : "Reverted");
      
      if (receipt.status === 0n) {
        // Transaction reverted - this means we hit a bomb or other contract logic failed
        setGameActive(false);
        setGameEndedWithBomb(true);
        setStatus("üí• Game Over - You hit a bomb!");
        
        // Don't reveal bomb positions even on game over
        setClickedTileSequence([]);
        return;
      }

      const parsedLogs = receipt.logs
        .map(log => {
          try {
            return contractInterface.parseLog(log);
          } catch (e) {
            return null;
          }
        })
        .filter(log => log !== null);

      const cashedOutEvent = parsedLogs.find(e => e.name === "CashedOut");
      const gameOverEvent = parsedLogs.find(e => e.name === "GameOver");

      if (gameOverEvent) {
        setGameActive(false);
        setGameEndedWithBomb(true);
        setStatus("üí• Game Over (Contract Confirmed)");
        setClickedTileSequence([]);
        return;
      }

      if (!cashedOutEvent) {
        const anyEvent = parsedLogs[0];
        if (anyEvent) {
          setGameActive(false);
          setClickedTileSequence([]);
          setGameEndedWithBomb(false);
          setStatus("üí∞ Cashout completed");
          return;
        }
        throw new Error("CashedOut event not found. Check contract events.");
      }

      const reward = parseFloat(ethers.formatEther(cashedOutEvent.args.reward));
      setTotalEarned(prev => prev + reward);
      setGameActive(false);
      setClickedTileSequence([]);
      setGameEndedWithBomb(false);
      setStatus(`üí∞ Cashed Out: ${reward.toFixed(4)} MON`);
    } catch (err) {
      console.error("Error cashing out:", err);
      setGameError(true);
      setGameErrorText(err.message);
      setStatus(`‚ùå Cashout failed: ${err.message}`);
    } finally {
      setIsTransactionPending(false);
    }
  };

  const calculateMultiplier = (safeClicks) => {
    let multiplier = 1.0;
    for (let i = 0; i < safeClicks; i++) {
      const prob = (36 - 9 - i) / (36 - i);
      multiplier *= (1 / prob);
    }
    return multiplier;
  };

  const selectBet = (amount) => {
    if (!gameActive && !isTransactionPending) {
      setSelectedBet(amount);
    }
  };

  const isGameControlsEnabled = authenticated && isWalletReady && !isTransactionPending;

  return (
    <div className="min-h-screen min-w-screen w-full h-full bg-gray-900 flex flex-col justify-center items-center">
      <div className="w-full max-w-2xl bg-white/10 backdrop-blur-lg rounded-3xl p-8 shadow-2xl border border-white/20">
        <h1 className="text-5xl font-bold mb-8 text-center bg-gradient-to-r from-purple-400 to-pink-400 bg-clip-text text-transparent">
          Monsweeper üí£
        </h1>
        
        {user && authenticated ? (
          <div className="text-center mb-6">
            <button 
              onClick={logout} 
              className="bg-white/20 backdrop-blur-sm text-white font-semibold py-2 px-6 rounded-full border border-white/30 hover:bg-white/30 transition-all duration-200 mb-3"
              disabled={isTransactionPending}
            >
              Disconnect
            </button>
            <p className="text-white/80 text-sm">Connected: {user?.wallet?.address?.slice(0, 6)}...{user?.wallet?.address?.slice(-4)}</p>
          </div>
        ) : (
          <div className="text-center mb-6">
            <button 
              onClick={login} 
              className="bg-gradient-to-r from-purple-500 to-pink-500 text-white font-semibold py-3 px-8 rounded-full hover:from-purple-600 hover:to-pink-600 transition-all duration-200 shadow-lg"
            >
              Connect Wallet
            </button>
          </div>
        )}

        {authenticated && (
          <div className="space-y-6">
            <div className="text-center">
              <p className="text-white/90 mb-4 font-medium">Select Bet Amount:</p>
              <div className="flex flex-wrap justify-center gap-3">
                {["0.01", "0.1", "1", "3", "5", "10"].map(amount => (
                  <button
                    key={amount}
                    onClick={() => selectBet(amount)}
                    className={`py-2 px-4 rounded-full font-semibold transition-all duration-200 border-2
                      ${selectedBet === amount 
                        ? "bg-white text-purple-900 border-white shadow-lg" 
                        : "bg-white/10 text-white border-white/30 hover:bg-white/20 hover:border-white/50"
                      }
                      ${(gameActive || isTransactionPending) ? "opacity-50 cursor-not-allowed" : "cursor-pointer"}`}
                    disabled={gameActive || isTransactionPending}
                  >
                    {amount} MON
                  </button>
                ))}
              </div>
            </div>

            <div className="text-center space-y-3">
              <button
                onClick={handleStartGame}
                className={`w-full max-w-xs bg-gradient-to-r from-green-500 to-emerald-500 text-white font-semibold py-3 px-6 rounded-full transition-all duration-200 shadow-lg hover:from-green-600 hover:to-emerald-600
                  ${(!isGameControlsEnabled || gameActive) ? "opacity-50 cursor-not-allowed" : "hover:scale-105"}`}
                disabled={!isGameControlsEnabled || gameActive}
              >
                {isTransactionPending ? "Starting..." : "Start Game"}
              </button>
              
              <button
                onClick={handleCashOut}
                className={`w-full max-w-xs bg-gradient-to-r from-yellow-500 to-orange-500 text-white font-semibold py-3 px-6 rounded-full transition-all duration-200 shadow-lg hover:from-yellow-600 hover:to-orange-600
                  ${(!isGameControlsEnabled || !gameActive || tilesClicked === 0) ? "opacity-50 cursor-not-allowed" : "hover:scale-105"}`}
                disabled={!isGameControlsEnabled || !gameActive || tilesClicked === 0}
              >
                {isTransactionPending ? "Cashing..." : `Cash Out (${(calculateMultiplier(tilesClicked) * 0.95 * parseFloat(selectedBet)).toFixed(4)} MON)`}
              </button>
            </div>

            {(gameActive || revealedTiles.some(tile => tile)) && (
              <div className="mt-8">
                <h3 className="text-2xl mb-6 text-center text-white font-semibold">
                  {gameEndedWithBomb ? "üí• Game Over" : "üéÆ Game Board"}
                </h3>
                <div className="flex justify-center">
                  <div 
                    className="grid gap-2 bg-white/10 backdrop-blur-sm p-4 rounded-2xl border border-white/20"
                    style={{ 
                      gridTemplateColumns: 'repeat(6, 1fr)', 
                      maxWidth: '360px'
                    }}
                  >
                    {tiles.map((tile, i) => {
                      const isRevealed = revealedTiles[i];
                      
                      return (
                        <div
                          key={i}
                          onClick={() => handleTileClick(i)}
                          className={`flex items-center justify-center font-bold text-lg transition-all duration-200 border-2 rounded-xl
                            ${!isRevealed 
                              ? "bg-white/20 text-white cursor-pointer hover:bg-white/30 active:scale-95 border-white/40" 
                              : tile === 2
                              ? "bg-gradient-to-br from-red-500 to-red-600 text-white animate-bounce border-red-400" 
                              : "bg-gradient-to-br from-green-500 to-emerald-500 text-white animate-pulse border-green-400"
                            }
                            ${(!gameActive || !isGameControlsEnabled || isRevealed || isTransactionPending) ? "cursor-not-allowed opacity-75" : ""}`}
                          style={{ 
                            width: '50px',
                            height: '50px',
                            pointerEvents: (!gameActive || !isGameControlsEnabled || isRevealed || isTransactionPending) ? 'none' : 'auto' 
                          }}
                        >
                          {isRevealed ? (tile === 2 ? "üí£" : "‚úÖ") : (i + 1)}
                        </div>
                      );
                    })}
                  </div>
                </div>
              </div>
            )}

            {gameActive && (
              <div className="mt-6 p-6 bg-white/10 backdrop-blur-sm rounded-2xl border border-white/20">
                <div className="grid grid-cols-1 md:grid-cols-3 gap-4 text-center">
                  <div>
                    <p className="text-white/80 text-sm">Safe Tiles</p>
                    <p className="text-2xl font-bold text-white">{tilesClicked}/27</p>
                  </div>
                  <div>
                    <p className="text-white/80 text-sm">Multiplier</p>
                    <p className="text-2xl font-bold text-green-400">{(calculateMultiplier(tilesClicked) * 0.95).toFixed(4)}x</p>
                  </div>
                  <div>
                    <p className="text-white/80 text-sm">Potential Win</p>
                    <p className="text-2xl font-bold text-yellow-400">{(calculateMultiplier(tilesClicked) * 0.95 * parseFloat(selectedBet)).toFixed(4)} MON</p>
                  </div>
                </div>
              </div>
            )}
          </div>
        )}

        <div className="mt-8 space-y-4 text-center">
          <p className="text-lg text-white font-medium">{status}</p>
          <div className="flex justify-center gap-6 text-sm">
            <p className="text-green-400">üìà +{totalEarned.toFixed(4)} MON</p>
            <p className="text-red-400">üìâ -{totalLost.toFixed(4)} MON</p>
          </div>
          <p className="text-white/70 text-sm">
            üéØ Find 27 safe tiles among 36. Avoid 9 bombs. Cash out anytime to secure winnings!
          </p>
        </div>

        {gameError && (
          <div className="mt-6 p-4 bg-red-500/20 backdrop-blur-sm border border-red-400/30 rounded-2xl">
            <p className="text-red-200 text-center">‚ùå Error: {gameErrorText}</p>
            <div className="text-center mt-3">
              <button 
                onClick={() => {
                  setGameError(false);
                  setGameErrorText("");
                }}
                className="bg-red-500 text-white px-4 py-2 rounded-full text-sm hover:bg-red-600 transition-colors"
              >
                Dismiss
              </button>
            </div>
          </div>
        )}
      </div>

      <div className="mt-8 text-center">
        <p className="text-white/60 text-sm">
          Made by{' '}
          <a 
            href="https://x.com/eric168eth" 
            target="_blank" 
            rel="noopener noreferrer"
            className="text-blue-400 hover:text-blue-300 transition-colors underline"
          >
            @eric168eth
          </a>
          {' '}and{' '}
          <a 
            href="https://x.com/0xbobaa" 
            target="_blank" 
            rel="noopener noreferrer"
            className="text-blue-400 hover:text-blue-300 transition-colors underline"
          >
            @0xbobaa
          </a>
        </p>
      </div>
    </div>
  );
}

export default App;